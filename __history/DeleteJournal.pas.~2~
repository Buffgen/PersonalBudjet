Unit DeleteJournal;

Interface

Uses
    Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
    Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.Grids, Vcl.StdCtrls;

Type
    TFormDeleteJournal = class(TForm)
        StringGridJournal: TStringGrid;
    ButtonExecute: TButton;
    procedure FormShow(Sender: TObject);
    procedure StringGridJournalDrawCell(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState);
    procedure ButtonExecuteClick(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);

    Private
        Procedure DeleteJournalStringGrid();
        Procedure DeleteJournalElement();

    Public
        { Public declarations }
    End;


Var
  FormDeleteJournal: TFormDeleteJournal;

Implementation
    {$R *.dfm}

Uses
    Main, Journal, UnitProcedure;




Procedure TFormDeleteJournal.DeleteJournalStringGrid();
Var
    I, J: Integer;
Begin
    For I := StringGridJournal.Row to StringGridJournal.RowCount - 1 do
    Begin
        For J := 0 to 4 do
            StringGridJournal.Cells[J,I] := StringGridJournal.Cells[J,I + 1];
    End;
    StringGridJournal.RowCount := StringGridJournal.RowCount - 1;
End;


Procedure TFormDeleteJournal.DeleteJournalElement();
Var
    CurrentPointer: PJournal;
    I: Integer;
Begin
    DataHasChanged := True;
    PointerJournal := HeadJournal;

    For I := 1 to StringGridJournal.Row do
        PointerJournal := PointerJournal^.Next;

    CurrentPointer := PointerJournal^.Next;
    PointerJournal^.Next := CurrentPointer^.Next;
    CurrentPointer^.Next := nil;
    Dispose(CurrentPointer);
    If PointerJournal^.Next = nil then
        TailJournal := PointerJournal;
    HeadJournal^.ID := HeadJournal^.ID - 1;
End;


procedure TFormDeleteJournal.ButtonExecuteClick(Sender: TObject);
begin
    If StringGridJournal.Row <> 0 then
    Begin
        DeleteJournalStringGrid();
        DeleteJournalElement();
    End;
end;


procedure TFormDeleteJournal.FormClose(Sender: TObject;
  var Action: TCloseAction);
begin
    FillJournal(FormJournal.StringGridJournal);
end;

Procedure TFormDeleteJournal.FormShow(Sender: TObject);
Begin
     SetStartJournal(StringGridJournal);
     FillJournal(StringGridJournal);
End;


procedure TFormDeleteJournal.StringGridJournalDrawCell(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TGridDrawState);
  Var
    CellText: String;
    SavedAlign: Word;
begin
    If (StringGridJournal.Row = ARow) and (StringGridJournal.Row <> 0) then
    Begin
        CellText := StringGridJournal.Cells[ACol, ARow];
        //Определяем цвет прямоугльника Rect
        StringGridJournal.Canvas.Brush.Color := clRed;
        //Заливаем прямоугльник Rect выбранным цветом
        StringGridJournal.Canvas.FillRect(Rect);
        //Текст тоже будет закрашен, его нужно перерисовать. Устанавливаем цвет текста.
        StringGridJournal.Canvas.Font.Color:=clWhite;
        StringGridJournal.Canvas.Font.Style := [fsBold];
        //Сохраняем предыдущую настройку расположения текста и устанавливаем вместо нее центрирование
        SavedAlign := SetTextAlign(StringGridJournal.Canvas.Handle, TA_LEFT);
        //Left - задает координату X верхнего левого угла прямоугольника.
        //Top - задает координату Y верхнего левого угла прямоугольника.
        //Right - задает координату X правого нижнего угла прямоугольника.
        //Bottom - указывает координату Y нижнего правого угла прямоугольника.
        //Стартовая координата X=0, Y=0 - левый верхний угол.
        //Устанавливаем координату для позиционирования квадрата с текстом
        //(Rect.Left + (Rect.Right - Rect.Left) div 2) - центр по горизонтали
        // Rect.Top + n - отступ по вертикали (вниз)
        StringGridJournal.Canvas.TextRect(Rect, Rect.Left + (Rect.Right - Rect.Left) div 2, Rect.Top + 2, CellText);
        // устанавливаем назад сохраненную предыдущую настройку расположения текста
        SetTextAlign(StringGridJournal.Canvas.Handle, SavedAlign);
    End
    Else
    Begin
        CellText := StringGridJournal.Cells[ACol, ARow];
        //Определяем цвет прямоугльника Rect
        StringGridJournal.Canvas.Brush.Color := clWindow;
        //Заливаем прямоугльник Rect выбранным цветом
        StringGridJournal.Canvas.FillRect(Rect);
        //Текст тоже будет закрашен, его нужно перерисовать. Устанавливаем цвет текста.
        StringGridJournal.Canvas.Font.Color:=clBlack;
        StringGridJournal.Canvas.Font.Style := [];
        //Сохраняем предыдущую настройку расположения текста и устанавливаем вместо нее центрирование
        SavedAlign := SetTextAlign(StringGridJournal.Canvas.Handle, TA_LEFT);
        //Left - задает координату X верхнего левого угла прямоугольника.
        //Top - задает координату Y верхнего левого угла прямоугольника.
        //Right - задает координату X правого нижнего угла прямоугольника.
        //Bottom - указывает координату Y нижнего правого угла прямоугольника.
        //Стартовая координата X=0, Y=0 - левый верхний угол.
        //Устанавливаем координату для позиционирования квадрата с текстом
        //(Rect.Left + (Rect.Right - Rect.Left) div 2) - центр по горизонтали
        // Rect.Top + n - отступ по вертикали (вниз)
        StringGridJournal.Canvas.TextRect(Rect, Rect.Left + (Rect.Right - Rect.Left) div 2, Rect.Top + 2, CellText);
        // устанавливаем назад сохраненную предыдущую настройку расположения текста
        SetTextAlign(StringGridJournal.Canvas.Handle, SavedAlign);
    End;
end;

End.
